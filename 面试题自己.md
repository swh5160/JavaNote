[JavaSE增强-第一章 static、单例与继承-java静态代码块，构造方法，构造代码块的执行先后顺序](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0%20static%E3%80%81%E5%8D%95%E4%BE%8B%E4%B8%8E%E7%BB%A7%E6%89%BF.md#java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F)

[JavaSE增强-第一章 static、单例与继承-单例模式](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0%20static%E3%80%81%E5%8D%95%E4%BE%8B%E4%B8%8E%E7%BB%A7%E6%89%BF.md#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)

[JavaSE增强-第二章 多态，抽象类-final、abstart、interface](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%9A%E6%80%81%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB.md)

[JavaSE增强-第八章可变参、Map、Stream-HashMap底层原理](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%8F%AF%E5%8F%98%E5%8F%82%E3%80%81Map%E3%80%81Stream.md#1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)

# 集合

###### **1、HashSet如何检查重复？**

​		hashset其实就是hashmap中的key，当调用add方法的时候，底层调用的是hashmap的put方法，首先会计算该数据hashcode值判断对象加入的位置，同时也会和其他对象的hashcode进行比较，如果不同直接插入数据，相同则调用Object的equals比较内容，内容不同jdk8之前插入数组上方，jdk8以后采用尾插法

###### **2、HashSet和TreeSet的区别？**

- 底层不同：

​		hashset底层采用的是哈希表实现的，TreeSet采用的是二叉树实现的

- 存放元素要求不同

  hashset实际上是hashmap的key，其中可以存放一个null元素，元素的无序、不重复

  treeset实际是treemap中的key，其中不能存放null，默认是有序的不重复，按着元素默认循序（自定义排序）

###### **3、HashMap和HashSet区别？**

底层hashset调用的hashmap，二者都采用了hash算法实现了唯一性，他们都不能持有基本类型

|                        | HashSet                | HashMap               |
| ---------------------- | ---------------------- | --------------------- |
| 实现接口               | Set                    | Map                   |
| 结构                   | 线性结构               | key-value键值对       |
| 添加方法               | add（）                | put（）               |
| 唯一性（计算hashcode） | 采用对象来计算hashcode | 采用key来计算hashcode |

###### **4、HashMap和HashTable区别？**

- 底层不一样

  hashtable:数组+链表；hashmap在jdk8以后是数组+链表+红黑树；解决hash冲突，当链表长度大于8，数组容量大于64转为红黑树，当链表长度大于8，数组小于64进行扩容，提升搜索效率

- 线程安全问题

  hashmap是线程不安全的，hashtable是线程安全的，每个方法都加了synchronized方法；

- 效率

  因为hashtable是线程安全的所以速度比hashmap慢一点

- 扩容

  - 不设置初始容量

    hashmap默认数组长度16，不加初始化参数每次扩容2的幂次方，负载因子0.75；hashtabel数组默认长度11，每次扩容2n+1，负载因子0.75

  - 设置初始化容量

    hashtabel直接按照初始化大小创建，hashmap是先扩容容量的2的幂次方

- 空值要求不一样

  - hashmap中key、value可以为null，但是key必须只有一个；而hashtabel不允许存在空值

- 方法

  hashMap 去掉了HashTable 的contains 方法，但是	Value ()和containsKey()方法。

###### **5、HashMap底层原理？**

put过程总结：

1、put时，会调用putVal(hash(key),key,value)方法，

2、其中hash(key)方法用来计算数组下标位置，key=null 返回0，否则用key的hashcode与key的hashcode右移16位做异或运算。

- 2.1 数组长度为int ，hashcode也是int32位；hashcode往往高位二进制为0，用不到无意义，所以采用右移16位使高位参与运算，采用异或运算出现结果平均散列分布。（相同为0不同为1）

3、如果没有发生碰撞，直接添加元素到散列表中去

4、如果发生了碰撞(hashCode 值相同)，进行三种判断

- 4.1:若key 地址相同或者equals 后内容相同，则替换旧值
- 4.2:如果是红黑树结构，就调用树的插入方法
- 4.3：链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，（jdk8之前是头插法，会产生死锁）插入之后判断链表个数是否到达变成红黑树的阙值8；也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。

5、如果桶满了大于阀值，则resize ()进行扩容，需要重新计算下标，扩容每次增加2倍（长度-1进行运算），下标可以有两种结果原始长度，原下标+原长度运算规则（**判断新长度和原长度按位与数字最高位是否为0，如果是0添加的数组就放在原下标位置，不是则原下标+原长度中**）

扩容机制

有三种情况

1、数组为空首次扩容

2、链表长度大于8，数组容量小于64进行扩容，每次扩容原来的2的幂次方

3、超过阈值（临界值），当数组长度>容量*负载因子扩容，扩容原来的两倍

（扩容时需要重新计算hash值，浪费时间，建议初始化容量，减少时间浪费）

其中负载因子为什么是0.75，其表示为hash表中元素填充程度（负载因子越大也就意味着出发扩容元素的个数就越多，空间利用率高，hash冲突也高）反之；hashmap采用链式寻址的方式解决hash冲突，避免过长会转为红黑树，负载因子为0.75，链表长度达到8的可能性很低，比较好做到时间和空间成本平衡。



###### **6、HashMap 和HashSet 区别？**

如果你看过HashSet 源码的话就应该知道：HashSet 底层就是基于HashMap实现的。（HashSet 的源码非常非常少，因为除了clone()、writeObject()、readObject()是HashSet 自己不得不实现之外，其他方法都是直接调用HashMap 中的方法。

| HashMap                           | HashSet                                                      |
| --------------------------------- | ------------------------------------------------------------ |
| 实现了Map接口                     | 实现Set 接口                                                 |
| 存储键值对                        | 仅存储对象                                                   |
| 调用put()向map中添加元素          | 调用add()方法向Set 中添加元素                                |
| HashMap 使用键（Key）计算hashcode | HashSet 使用成员对象来计算hashcode 值，对于两个对象来说hashcode 可能相同，所以equals()方法用来判断对象的相等性 |

 





# 线程

###### 1、线程创建的几种方式？

###### 2、线程状态转换？

new 创建 （未调用start）
runnable 就绪可运行（调用start 具体执行根据cpu情况）
blocked 阻塞锁
waiting 无限等待
timed waiting 计时等待
teminated 被终止

两种情况
    ●不顺畅路线
        ■一个线程没有拿到锁，就进入了blocked锁阻塞状态，拿到锁了就进入可运行状态；
        ■一个线程被wait无限等待，被notify唤醒拿到锁可运行， 没拿到锁阻塞
        ■计时等待
            a.如果是sleep拿着锁休眠，休眠后回到可运行，
            b.如果是wait（带时间），到时间有锁可运行，无锁变成锁阻塞；未到时间被notify唤醒，有锁可运行，无锁变为锁阻塞
    ●有锁顺畅路线
    创建new一个线程，调用start方法进入runnable就绪状态，cpu刚好调用这个线程持有锁，（或者异常结束）变成被终止teminated状态

###### 3、start和run区别？

start调用的是start0（）方法，该线程并一定会立马执行，只是将线程变成了可运行状态，具体什么时候执行取决于cpu，由cpu调度。

java中实现真正的多线程是start中的start0（）方法，run方法只是一个普通方法。

###### 4、sleep和wait区别？

- sleep方法被Thread类调用（静态），wait（）是object类的方法，锁对象调用
- thread.sleep可以在任意地方使用，wait只能在同步代码块/同步方法中使用
- Thread.sleep如果该线程持有锁（不会释放），wait（）如果线程持有锁会释放锁

###### 5、TimeUnit.MILLISECONDS.sleep(0)是什么意思？

一瞬间让一下资源；放弃现在申请的资源

