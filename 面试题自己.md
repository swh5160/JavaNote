[JavaSE增强-第一章 static、单例与继承-java静态代码块，构造方法，构造代码块的执行先后顺序](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0%20static%E3%80%81%E5%8D%95%E4%BE%8B%E4%B8%8E%E7%BB%A7%E6%89%BF.md#java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F)

[JavaSE增强-第一章 static、单例与继承-单例模式](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E4%B8%80%E7%AB%A0%20static%E3%80%81%E5%8D%95%E4%BE%8B%E4%B8%8E%E7%BB%A7%E6%89%BF.md#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)

[JavaSE增强-第二章 多态，抽象类-final、abstart、interface](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%9A%E6%80%81%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB.md)

[JavaSE增强-第八章可变参、Map、Stream-HashMap底层原理](https://gitee.com/shi-zian/JavaNote/blob/main/JavaSE%E5%A2%9E%E5%BC%BA/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%8F%AF%E5%8F%98%E5%8F%82%E3%80%81Map%E3%80%81Stream.md#1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)

# 集合

###### **1、HashSet如何检查重复？**

​		hashset其实就是hashmap中的key，当调用add方法的时候，底层调用的是hashmap的put方法，首先会计算该数据hashcode值判断对象加入的位置，同时也会和其他对象的hashcode进行比较，如果不同直接插入数据，相同则调用Object的equals比较内容，内容不同jdk8之前插入数组上方，jdk8以后采用尾插法

###### **2、HashSet和TreeSet的区别？**

- 底层不同：

​		hashset底层采用的是哈希表实现的，TreeSet采用的是二叉树实现的

- 存放元素要求不同

  hashset实际上是hashmap的key，其中可以存放一个null元素，元素的无序、不重复

  treeset实际是treemap中的key，其中不能存放null，默认是有序的不重复，按着元素默认循序（自定义排序）

###### **3、HashMap和HashSet区别？**

底层hashset调用的hashmap，二者都采用了hash算法实现了唯一性，他们都不能持有基本类型

|                        | HashSet                | HashMap               |
| ---------------------- | ---------------------- | --------------------- |
| 实现接口               | Set                    | Map                   |
| 结构                   | 线性结构               | key-value键值对       |
| 添加方法               | add（）                | put（）               |
| 唯一性（计算hashcode） | 采用对象来计算hashcode | 采用key来计算hashcode |

###### **4、HashMap和HashTable区别？**

- 底层不一样

  hashtable:数组+链表；hashmap在jdk8以后是数组+链表+红黑树；解决hash冲突，当链表长度大于8，数组容量大于64转为红黑树，当链表长度大于8，数组小于64进行扩容，提升搜索效率

- 线程安全问题

  hashmap是线程不安全的，hashtable是线程安全的，每个方法都加了synchronized方法；

- 效率

  因为hashtable是线程安全的所以速度比hashmap慢一点

- 扩容

  - 不设置初始容量

    hashmap默认数组长度16，不加初始化参数每次扩容2的幂次方，负载因子0.75；hashtabel数组默认长度11，每次扩容2n+1，负载因子0.75

  - 设置初始化容量

    hashtabel直接按照初始化大小创建，hashmap是先扩容容量的2的幂次方

- 空值要求不一样

  - hashmap中key、value可以为null，但是key必须只有一个；而hashtabel不允许存在空值

- 方法

  hashMap 去掉了HashTable 的contains 方法，但是	Value ()和containsKey()方法。

###### **5、HashMap底层原理？**

put过程总结：

1、put时，会调用putVal(hash(key),key,value)方法，

2、其中hash(key)方法用来计算数组下标位置，key=null 返回0，否则用key的hashcode与key的hashcode右移16位做异或运算。

- 2.1 数组长度为int ，hashcode也是int32位；hashcode往往高位二进制为0，用不到无意义，所以采用右移16位使高位参与运算，采用异或运算出现结果平均散列分布。（相同为0不同为1）

3、如果没有发生碰撞，直接添加元素到散列表中去

4、如果发生了碰撞(hashCode 值相同)，进行三种判断

- 4.1:若key 地址相同或者equals 后内容相同，则替换旧值
- 4.2:如果是红黑树结构，就调用树的插入方法
- 4.3：链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，（jdk8之前是头插法，会产生死锁）插入之后判断链表个数是否到达变成红黑树的阙值8；也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。

5、如果桶满了大于阀值，则resize ()进行扩容，需要重新计算下标，扩容每次增加2倍（长度-1进行运算），下标可以有两种结果原始长度，原下标+原长度运算规则（**判断新长度和原长度按位与数字最高位是否为0，如果是0添加的数组就放在原下标位置，不是则原下标+原长度中**）

扩容机制

有三种情况

1、数组为空首次扩容

2、链表长度大于8，数组容量小于64进行扩容，每次扩容原来的2的幂次方

3、超过阈值（临界值），当数组长度>容量*负载因子扩容，扩容原来的两倍

（扩容时需要重新计算hash值，浪费时间，建议初始化容量，减少时间浪费）

其中负载因子为什么是0.75，其表示为hash表中元素填充程度（负载因子越大也就意味着出发扩容元素的个数就越多，空间利用率高，hash冲突也高）反之；hashmap采用链式寻址的方式解决hash冲突，避免过长会转为红黑树，负载因子为0.75，链表长度达到8的可能性很低，比较好做到时间和空间成本平衡。



###### **6、HashMap 和HashSet 区别？**

如果你看过HashSet 源码的话就应该知道：HashSet 底层就是基于HashMap实现的。（HashSet 的源码非常非常少，因为除了clone()、writeObject()、readObject()是HashSet 自己不得不实现之外，其他方法都是直接调用HashMap 中的方法。

| HashMap                           | HashSet                                                      |
| --------------------------------- | ------------------------------------------------------------ |
| 实现了Map接口                     | 实现Set 接口                                                 |
| 存储键值对                        | 仅存储对象                                                   |
| 调用put()向map中添加元素          | 调用add()方法向Set 中添加元素                                |
| HashMap 使用键（Key）计算hashcode | HashSet 使用成员对象来计算hashcode 值，对于两个对象来说hashcode 可能相同，所以equals()方法用来判断对象的相等性 |

 





# 线程

###### 1、线程创建的几种方式？

###### 2、线程状态转换？

new 创建 （未调用start）
runnable 就绪可运行（调用start 具体执行根据cpu情况）
blocked 阻塞锁
waiting 无限等待
timed waiting 计时等待
teminated 被终止

两种情况

- 不顺畅路线

  - 一个线程没有拿到锁，就进入了blocked锁阻塞状态，拿到锁了就进入可运行状态；

  - 一个线程被wait无限等待，被notify唤醒拿到锁可运行， 没拿到锁阻塞

  - 计时等待
    - a.如果是sleep拿着锁休眠，休眠后回到可运行，
    - b.如果是wait（带时间），到时间有锁可运行，无锁变成锁阻塞；未到时间被notify唤醒，有锁可运行，无锁变为锁阻塞

- 有锁顺畅路线
  - 创建new一个线程，调用start方法进入runnable就绪状态，cpu刚好调用这个线程持有锁，（或者异常结束）变成被终止teminated状态
  
  

###### 3、start和run区别？

start调用的是start0（）方法，该线程并一定会立马执行，只是将线程变成了可运行状态，具体什么时候执行取决于cpu，由cpu调度。

java中实现真正的多线程是start中的start0（）方法，run方法只是一个普通方法。

###### 4、sleep和wait区别？

- sleep方法被Thread类调用（静态），wait（）是object类的方法，锁对象调用
- thread.sleep可以在任意地方使用，wait只能在同步代码块/同步方法中使用
- Thread.sleep如果该线程持有锁（不会释放），wait（）如果线程持有锁会释放锁

###### 5、TimeUnit.MILLISECONDS.sleep(0)是什么意思？

一瞬间让一下资源；放弃现在申请的资源

/**/未完待续



# 数据库mysql

###### 1、什么是DDL、DML、DCL区别？

- SQL语句根据其功能被分为四大类：DDL、DML、DQL、DCL 

  | **分类** | **全称**                    | **说明**                                               |
  | -------- | --------------------------- | ------------------------------------------------------ |
  | DDL      | Data Definition  Language   | 数据定义语言，用来定义数据库对象(数据库，表，字段)     |
  | DML      | Data Manipulation  Language | 数据操作语言，用来对数据库表中的数据进行增删改         |
  | DQL      | Data Query Language         | 数据查询语言，用来查询数据库中表的记录                 |
  | DCL      | Data Control  Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |

###### 2、mysql中unsigned、signed、零填充(zerofill)区别？

unsigned 是mysql自定义的类型，表示无符号数值即非负数。signed为整型默认属性。

区别1：起到约束数值的作用。

区别2：可以增加数值范围。

以tinyint为例，它的取值范围-128-127，加不加signed都默认此范围。加上unsigned表示范围0-255，其实相当于把负数那部分加到正数上。例如身高、体重或者年龄等字段一般不会为负数，此时就可以设置一个 UNSIGNED ，不允许负数插入。

      zerofill零填充会自动使用无符号位。零填充指的是位数固定，如果数值长度不足字段类型的长度，则使用0来填充。比如zerofill 的int数值，设为123，数据库中会显示0000000123；
###### 3、mysql引擎有哪些？

（1）InnoDB 存储引擎 InnoDB 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB 是默认的 MySQL 引擎。 

（2）MyISAM 存储引擎 MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。 

（3）MEMORY(Heap) 存储引擎 MEMORY 存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。如果数据库重启或崩溃，数 据丢失，因此它非常适合存储临时数据。  

（4）NDB 存储引擎 NDB 存储引擎是一个集群存储引擎，类似于 Oracle 的 RAC，但它是 Share Nothing 的架构，因此能提供更高级别的高可用性和可扩展性。NDB 的特点是数据全部放在内存中，因此通过主键查找非常快。 关于 NDB，有一个问题需要注意，它的连接(join)操作是在 MySQL 数据库层完成，不是在存储引擎层完成，这意味着，复杂的 join 操作需要巨大的网络开销，查询速度会很慢。 

（5）、Archive 存储引擎 正如其名称所示，Archive 非常适合存储归档数据，如日志信息。它只支持 INSERT 和 SELECT 操作，其设计的主要目的是提供高速的插入和压缩功能。 

（6）、Federated 存储引擎 Federated 存储引擎不存放数据，它至少指向一台远程 MySQL 数据库服务器上的表，非常 类似于 Oracle 的透明网关。 

（7）、Maria 存储引擎 Maria 存储引擎是新开发的引擎，其设计目标是用来取代原有的 MyISAM 存储引擎，从而成为 MySQL 默认的存储引擎。 

上述引擎中，InnoDB 是事务安全的存储引擎，设计上借鉴了很多 Oracle 的架构思想， 一般而言，在 OLTP 应用中，InnoDB 应该作为核心应用表的首先存储引擎。

###### 4、数据库事务ACID四大特性？

- **原子性（Atomicity）** ：原子性是指事务包装的一组sql是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

- **一致性（Consistency）**：一个事务完成之后数据都必须处于一致性状态。

​		如果事务成功的完成，那么数据库的所有变化将生效。

​		如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。

- **隔离性（Isolation）**：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。

​		一个事务的成功或者失败对于其他的事务是没有影响。

- **持久性（Durability）**：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。

###### 5、mysql有哪几种索引？

